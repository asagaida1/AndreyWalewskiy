Метод finalize
finalize() необходим при работе с нативным кодом и освобождения ресурсов там, а исключить вероятность работы Java
с С-кодом, например, нельзя. Как Вы решили бы проблему освобождения ресурсов, созданных при работе с не Java-кодом
внутри Java -кода?
У Джошуа Блоха хорошо написано об этом методе: link
Краткая выдержка:
1. finalize() можно использовать только в двух случаях:
1.1. Проверка/подчистка ресурсов с логированием
1.2. При работе с нативным кодом, который не критичен к утечке ресурсов
2. finalize() замедляет работу GC по очистке объекта в 430 раз
3. finalize() может быть не вызван

=========================
вопросы на собеседование:

Какие ексепшены могут вызываться при работе с файлами?
==============
Какие варианты обрабытки ошибок ты знаешь?
Пробросить или try catch. Предпочел бы обработать try catch что бы друго разработчик смог понять почему он вызвался.
==============
Когда не отработает Finaly?
1) Error
2) Java программа принудительно остановленна и очередь до отрабатывания Finaly не дошла.
3) когда Finaly в потоке Демон. А когда завершается работа Java программы, Java не дожидается завершения работы потоков Демон.
===============
Нормализация БД.
    1НФ - первая нормальная форма
    2НФ - вторая нормальная форма
    3НФ - третья нормальная форма
    НФБК - нормальная форма Бойса-Кодда
    4НФ - четвертая нормальная форма
    5НФ - пятая нормальная форма
1НФ:
-Все строки должны быть различными.
-Все элементы внутри ячеек должны быть атомарными (не списками).
2НФ:
-Таблица должна находиться в первой нормальной форме.
-Любое её поле, не входящее в состав первичного ключа, функционально полно зависит от первичного ключа.
Если Ваша таблица приведена к первой нормальной форме и у нее установлен уникальный id для каждой строки, то она находится и во второй нормальной форме.
|Деталь, pk||	Склад, pk 	|| Количество ||  Адрес склада |

Нужно разделить на две таблицы:
|Склад, pk ||	Адрес склада|
|Деталь, pk ||	Склад, pk || Количество |

3НФ
- Таблица находится во второй нормальной форме.
- Любой её не ключевой атрибут функционально зависит только от первичного ключа.
Проще говоря, второе правило требует выносить все не ключевые поля, содержимое которых может относиться к нескольким записям таблицы в отдельные таблицы.
Нужно разделить на две таблицы:
|N табельный,PK ||	Фамилия ||	Имя ||	Отчество ||	Код должности ||	Оклад|
|N табельный,PK ||	Фамилия ||	Имя ||	Отчество ||	Код должности |
|Код должности ||	Оклад|

НФБК
- Таблица находится в третьей нормальной форме.
- Усиленная 3НФ. значения в таблицах это FK, а не имена/названия, + например поля с количеством, если они нужны или лни есть.
==============

Что такое консистентность базы?
()
==============
Отличия Inner Join от Left Join и Outer Join?
Inner Join - объединяем две таблицы и результат только общее совпадение
Left Join - объединяем две таблицы и результат полная таблица слева и значения правой они либо есть либо Null
Outer Join - объединяем две таблицы и результат все возможные совпадения
==============

Преимущества Hibenate перед JDBC?
- Hibenate сам строит запросы к БД.
- сам мапит объекты на наше приложение (Почитать про это)
- Удобство разработки
- Проще (не понятно почему)
- Из минусов - это меньше скорость работы (HQL Criteria)по сравнению с JDBC.
==============
Кеширование в Hibenate

==============
Проблемы с кеширование в Hibenate?

==============

Виды контекста в Hibenate?
==============
Скоупы в Spring (Какие есть, для чего нужны)
- Скоуп по умолчанию это Singleton;
==============
Отличие Контролера от Рест контроллера?

==============
Что такое Rest архитектура?

==============











